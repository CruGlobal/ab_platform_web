/*
 * ABQL
 *
 * An ABQL defines the base class for our AB Query Language Objects.
 * These classes share a common way to
 *   - parse input strings for commands
 *
 *
 */
const ABQLCore = require("../../core/ql/ABQLCore.js");
const RowUpdater = require("../RowUpdater.js").default;

const L = (...params) => AB.Multilingual.label(...params);

class ABQL extends ABQLCore {
   // constructor(attributes, parameterDefinitions, prevOP, task, application) {
   //     super(attributes, parameterDefinitions, prevOP, task, application);
   // }

   ///
   /// Instance Methods
   ///

   /**
    * @method parseRow()
    * When it is time to pull the information from the properties panel,
    * use this fn to get the current Row of data.
    *
    * This fn() will populate the this.params with the values for each
    * of our .parameterDefinitions.
    *
    * @param {webixNode} row
    *        the current webix node that contains the ROW defining the
    *        operation and it's parameters.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    */
   parseRow(row, id) {
      // const allColumns = row.getChildViews();
      // allColumns.shift(); // remove selector
      this.parameterDefinitions.forEach((pDef) => {
         // const col = allColumns.shift();
         const myID = this.uiID(id);

         this.ids = this.toIDs(myID);
         this.params = this.params ?? {};

         let $uiCondition = null;

         switch (pDef.type) {
            case "objectFields":
               this.params[pDef.name] = $$(this.ids.objectfields).getValue();

               break;

            case "objectName":
               this.params[pDef.name] = $$(this.ids.objectname).getValue();

               break;

            case "objectConditions":
            case "objectValues":
               $uiCondition = $$(this.ids.condition);

               if ($uiCondition) {
                  const condition = $uiCondition.getValue();

                  if (condition && condition !== "") {
                     this.params[pDef.name] = JSON.parse(condition);
                  }
               }

               break;

            case "taskParam":
               this.params[pDef.name] = $$(this.ids.taskparam).getValue();

               break;
         }
      });
   }

   /*
    * @method toIDs()
    * generate a set of unique webix ids to use for our UI.
    * @param {string} myID
    *        the unique id generated by .uiID()
    */
   toIDs(myID) {
      return {
         condition: `${myID}_condition`,
         objectfields: `${myID}_objectfields`,
         objectname: `${myID}_objname`,
         popup: `${myID}_popup`,
         select: `${myID}_select`,
         shorthand: `${myID}_shorthand`,
         taskparam: `${myID}_taskparam`,
         spacer: `${myID}_spacer`,
      };
   }

   /**
    * @method uiAddParamForDef()
    * Add an operation parameter for each parameterDefinition we have defined.
    * @param {obj} pDef
    *        the current parameterDefinition entry we are creating the UI
    *        for.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @param {obj} ui
    *        the current webix ui definition we are building.
    */
   uiAddParamForDef(pDef, id, ui) {
      // params are added to a .col[] definition.
      // if our ui isn't down to the current .col element, then drill down
      if (!ui.cols) {
         if (ui.rows) {
            for (let i = 0; i < ui.rows.length; i++)
               if (ui.rows[i].cols) {
                  this.uiAddParamForDef(pDef, id, ui.rows[i]);

                  break;
               }
         } else throw new Error("provided ui is not able to add a parameter!");

         return;
      }

      const paramUI = this.uiParamUI(pDef, id);

      if (paramUI) {
         // if we only have 1 param
         if (this.parameterDefinitions.length === 1) {
            ui.cols.pop();
            ui.cols.push(paramUI);
         }
         // if we haven't already added a parameter
         else {
            // create a row stack of parameters:
            if (ui.cols.length < 3)
               ui.cols.push({
                  rows: [paramUI],
               });
            // add to the current stack of parameters
            else ui.cols[2].rows.push(paramUI);
         }
      }
   }

   /**
    * @method uiAddNext()
    * Add the next row selector for this operation:
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @param {obj} ui
    *        the current webix ui definition we are building.
    */
   uiAddNext(id, ui) {
      const uiRow = this.uiNextRow(id);

      // if we have a next operation defined, then add on the ui definitions
      // for that operation:
      if (this.next) {
         this.next.uiAddParams(id, uiRow);
         ui.rows.push(uiRow);
         this.next.uiAddNext(id, ui);
      }
      // otherwise we just leave the selector:
      else ui.rows.push(uiRow);
   }

   /**
    * @method uiAddParams()
    * Add operation parameter(s) for each parameterDefinition we have defined.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @param {obj} ui
    *        the current webix ui definition we are building.
    */
   uiAddParams(id, ui) {
      this.parameterDefinitions.forEach((pDef) => {
         this.uiAddParamForDef(pDef, id, ui);
      });
   }

   /*
    * @method uiID()
    * generate a unique webix id for this operation.
    * @param {string} id
    *        the webix id of the base property.query holder
    */
   uiID(id) {
      if (this.prevOP) return `${this.prevOP.uiID(id)}_${this.constructor.key}`;

      return `${id}_${this.constructor.key}`;
   }

   /*
    * uiXXX Operations:
    * are UI building operations that are performed BEFORE the webix UI
    * is generated.  They work by filling out a {ui} object definition
    * that webix will eventually create into the DOM.
    *
    * viewXXX Operations:
    * are UI building operations that are performed AFTER the webix UI
    * is generated. They work by adding in child views to an existing
    * DOM.
    */

   /**
    * @method uiNextRow()
    * return the webix UI definition for the next of UI chaining.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @return {obj}
    */
   uiNextRow(id) {
      const options = this.constructor.NextQLOps.map((op) => {
         return { id: op.key, value: op.label };
      });

      options.unshift({ id: 0, value: L("choose next operation") });

      const myID = this.uiID(id);
      const ids = this.toIDs(myID);

      const uiRow = {
         cols: [
            {
               id: ids.select,
               view: "select",
               value: this.next ? this.next.constructor.key : 0,
               options: options,
               on: {
                  onChange: (newValue, oldValue) => {
                     const resetValue = () => {
                        const select = $$(ids.select);

                        select.blockEvent();
                        select.setValue(oldValue);
                        select.unblockEvent();
                     };

                     if (newValue === oldValue) return;

                     const newOP = this.constructor.NextQLOps.find(
                        (op) => op.key === newValue
                     );

                     if (!newOP) {
                        resetValue();

                        return;
                     }

                     const thisRow = $$(ids.select).getParentView();
                     const thisQuery = thisRow.getParentView();
                     const addOP = () => {
                        if (newOP) {
                           const nextOP = new newOP(
                              {},
                              this,
                              this.task,
                              this.AB
                           );

                           this.next = nextOP;

                           nextOP.viewAddParams(id, thisRow);
                           nextOP.viewAddNext(id, thisQuery);
                        }
                     };

                     // if there are rows after this one, then warn
                     // about changing
                     const allRows = thisQuery.getChildViews();

                     if (allRows.length - 1 > allRows.indexOf(thisRow))
                        webix.confirm({
                           title: "continue?",
                           text: "changing this rule will reset any following rules.",
                           ok: "yes",
                           cancel: "no",
                           callback: (result) => {
                              if (result) {
                                 // remove the current additional Rows:
                                 let ir = allRows.length - 1;

                                 while (
                                    allRows[ir].config.id !== thisRow.config.id
                                 ) {
                                    thisQuery.removeView(allRows[ir]);
                                    ir--;
                                 }

                                 // now remove the parameters
                                 const allCols = thisRow.getChildViews();

                                 let ic = allCols.length;

                                 while (ic > 1) {
                                    thisRow.removeView(allCols[ic - 1]);
                                    ic--;
                                 }

                                 addOP();
                              } else resetValue();
                           },
                        });
                     else addOP();
                  },
               },
            },
            {
               id: ids.spacer,
            },
         ],
      };

      return uiRow;
   }

   uiNextRowSelectorRefresh(id) {
      const $select = $$(this.ids.select);

      if (!$select) return;

      const uiNextRow = this.uiNextRow(id);

      webix.ui(uiNextRow.cols[1], $select);
   }

   /**
    * @method uiParamUI()
    * return the webix UI definition for the parameter entry of this current
    * operation.
    * @param {obj} pDef
    *        the current parameterDefinition entry we are creating the UI
    *        for.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @return {obj}
    */
   uiParamUI(pDef, id) {
      const uiConfig = AB.Config.uiSettings();

      let myID = this.uiID(id);

      this.ids = this.toIDs(myID);

      let paramUI = null;
      let options = null;
      let Filter = null;
      let hashFieldIDs = null;
      let initialCond = null;
      let displayLabel = null;
      let initialValue = null;
      let Updater = null;
      let popUp = null;

      // now add the parameter
      switch (pDef.type) {
         case "objectFields":
            // an objectFields parameter returns a select list of fields
            // available on an Object.
            if (this.object)
               options = this.object.fields().map((f) => {
                  return { id: f.id, value: f.label };
               });

            options.unshift({
               id: "_PK",
               value: "[PK]",
            });

            // if not set, default .fieldID to the 1st entry in options
            // so we will have a default.  In use, if a user sees the
            // 1st item and continues on, then we will have chosen it.
            if (!this.fieldID && options.length > 0) {
               // act like it was selected:
               this.params[pDef.name] = options[0].id;
               this.paramChanged(pDef, id);
            }

            paramUI = {
               id: this.ids.objectfields,
               view: "select",
               label: "Field",
               labelWidth: 70,
               value: this.fieldID,
               options: options,
               on: {
                  onChange: (newValue, oldValue) => {
                     // this.params = this.params ?? {};
                     if (newValue !== this.params[pDef.name]) {
                        this.params[pDef.name] = newValue;
                        this.paramChanged(pDef, id);
                     }
                  },
               },
            };

            break;

         case "objectName":
            // an objectName parameter returns a select list of available
            // objects in this ABFactory.
            options = this.AB.objects().map((o) => {
               return { id: o.id, value: o.label };
            });

            if (!this.objectID && options.length > 0) {
               this.objectID = options[0].id;
               this.params[pDef.name] = this.objectID;
               this.paramChanged(pDef);
            }

            paramUI = {
               id: this.ids.objectname,
               view: "select",
               label: L("Data Source"),
               labelWidth: uiConfig.labelWidthLarge,
               value: this.objectID,
               options: options,
               on: {
                  onChange: (newValue /*, oldValue */) => {
                     this.params = this.params ?? {};

                     if (newValue !== this.params[pDef.name]) {
                        this.params[pDef.name] = newValue;
                        this.paramChanged(pDef);
                     }
                  },
               },
            };

            break;

         case "objectConditions":
            // objectConditions: returns a filter text summary, that when
            // clicked, pops up a Filter Entry Popup.
            // the actual value is stored in a hidden field.

            // we will create a new FilterComplex() object to use for our
            // filtering.
            // Our goal is to create a special filter entry for each avaiable
            // process data value that is available.
            // A filter entry needs to look like:
            // {
            //     id: `{string}`,      // A unique id selector for this filter
            //     name: `{string}`,    // the operation name displayed
            //     type, {obj}          // an object defining the editor to show
            //     fn: ()=>{}           // a function used for filtering elements
            // }
            //
            // In our filters, we are assigning filters to EACH field by the
            // field.id.  So the type definition needs to look like:
            // {
            //     "uniqueID of the field (field.id)" : {webixUI definition}
            // }

            Filter = this.AB.filterComplexNew(id);
            hashFieldIDs = this.availableProcessDataFieldsHash();

            if (this.object) {
               Filter.fieldsLoad(this.object.fields(), this.object);
               // NOTE: this will create default filters based upon the
               // object fields() and their types

               // Now we need to add in the Process Data Fields:
               // for each Process Data Field that matches our same object
               const foundFields = Object.keys(hashFieldIDs).map(
                  (f) => hashFieldIDs[f]
               );

               Filter.processFieldsLoad(foundFields);
               /*
               (foundFields ?? []).forEach((processField) => {
                  const type = {};
                  if (processField.field) {
                     type[processField.field.id] = {
                        view: "select",
                        options: [
                           {
                              id: "empty",
                              value: "choose option"
                           },
                           {
                              id: processField.key,
                              value: `context(${processField.label})`
                           }
                        ]
                     };
                  } else {
                     // if there is no .field, it is probably an embedded special field
                     // like: .uuid
                     const key = processField.key.split(".").pop();
                     type[key] = {
                        view: "select",
                        options: [
                           {
                              id: "empty",
                              value: "choose option"
                           },
                           {
                              id: processField.key,
                              value: `context(${processField.label})`
                           }
                        ]
                     };
                  }

                  // add an "equals" and "not equals" filter for each:
                  Filter.filterAdd([
                     {
                        id: `context_equals`,
                        name: `equals`,
                        type,
                        fn: (a, b) => {
                           return a === b;
                        }
                     },
                     {
                        id: `context_not_equal`,
                        name: `not equals`,
                        type,
                        fn: (a, b) => {
                           return a !== b;
                        }
                     }
                  ]);
                  
               }); */
            }

            // every time the Filter "saves" it's data, it emits this event:
            // take the given condition and store it in our hidden element.
            Filter.on("save", (condition) => {
               // @param {obj} condition an object describing the filter
               // condition.

               this.params = this.params ?? {};
               this.params[pDef.name] = condition;

               const shortHand = $$(this.ids.shorthand);

               shortHand.define({
                  label: Filter.toShortHand(),
               });
               shortHand.refresh();

               // NOTE: the hidden element is a text field, so convert the
               // {condition object} => a string
               const elCondition = $$(this.ids.condition);

               elCondition.define({
                  value: JSON.stringify(this.params[pDef.name]),
               });
               elCondition.refresh();
            });

            // create the initial condition value from our inputs.
            initialCond = "";

            if (this.params && this.params[pDef.name]) {
               Filter.setValue(this.params[pDef.name]);
               initialCond = JSON.stringify(this.params[pDef.name]);
            }

            // what we show on the panel, is a text representation
            // of the current condition.
            displayLabel = Filter.toShortHand();

            paramUI = {
               rows: [
                  {
                     id: this.ids.shorthand,
                     view: "button",
                     label: displayLabel,
                     on: {
                        onItemClick: () => {
                           Filter.popUp();
                        },
                     },
                  },
                  // have a hidden field to contain the condition
                  // value we will parse out later
                  {
                     id: this.ids.condition,
                     view: "text",
                     value: initialCond,
                     hidden: true,
                  },
               ],
            };

            break;

         case "objectValues":
            // objectValues : shows a condenced textual representation of the
            // field => value changes.  Clicking on the text will show a popup
            // that allows you to add/remove additional field updates for
            // the current object.

            initialValue = "";
            Updater = new RowUpdater(myID, this.AB);

            if (this.object) Updater.objectLoad(this.object);

            // Set processed data key to value options
            Updater.setExtendedOptions(
               (this.task.process.processDataFields(this.task) ?? []).map(
                  (item) => {
                     return {
                        id: item.key,
                        value: item.label,
                     };
                  }
               )
            );

            // NOTE: .setValue() must be called once the RowUpdater is already
            // displayed.  See the end of popUp() below:
            if (this.params && this.params[pDef.name]) {
               Updater.setValue(this.params[pDef.name]);
               initialValue = JSON.stringify(this.params[pDef.name]);
            }

            popUp = () => {
               // show the RowUpdater in a popup:
               const ui = {
                  id: this.ids.popup,
                  view: "popup",
                  position: "center",
                  minWidth: 700,
                  modal: true,
                  resize: true,
                  body: {
                     rows: [
                        {
                           height: 30,
                           borderless: true,
                           cols: [
                              { fillspace: true },
                              {
                                 view: "button",
                                 value: "X",
                                 width: 30,
                                 click: () => {
                                    $$(this.ids.popup).hide();
                                 },
                              },
                           ],
                        },
                        Updater.ui(),
                        {
                           view: "button",
                           value: L("Save"),
                           css: "webix_primary",
                           click: () => {
                              this.params = this.params ?? {};
                              this.params[pDef.name] = Updater.getValue();
                              const sh = $$(this.ids.shorthand);

                              sh.define({
                                 badge: this.params[pDef.name].length,
                              });
                              sh.refresh();

                              const cond = $$(this.ids.condition);

                              cond.define({
                                 value: JSON.stringify(this.params[pDef.name]),
                              });
                              cond.refresh();

                              $$(this.ids.popup).hide();
                           },
                        },
                     ],
                  },
               };

               // create and show the popup
               this._myPopup = webix.ui(ui);
               this._myPopup.show();

               // NOTE: on a RowUpdater, the values need to be set
               // AFTER it is displayed:
               if (this.params && this.params[pDef.name])
                  Updater.setValue(this.params[pDef.name]);
            };

            paramUI = {
               rows: [
                  // the textual shorthand for these values
                  {
                     id: this.ids.shorthand,
                     view: "button",
                     label: L("Update Popout"),
                     badge: this.params[pDef.name]?.length,
                     on: {
                        onItemClick: () => {
                           popUp();
                        },
                     },
                  },
                  // the hidden field that contains the results
                  {
                     id: this.ids.condition,
                     view: "text",
                     value: initialValue,
                     hidden: true,
                  },
               ],
            };

            break;

         case "taskParam":
            paramUI = {
               id: this.ids.taskparam,
               view: "text",
               label: "Variable",
               labelWidth: 70,
               value: this.params[pDef.name],
               placeholder: "Enter parameter name",
               on: {
                  onChange: (newValue, oldValue) => {
                     // this.params = this.params ?? {};
                     if (newValue !== this.params[pDef.name]) {
                        this.params[pDef.name] = newValue;
                        this.paramChanged(pDef, id);
                     }
                  },
               },
            };

            break;
      }

      return paramUI;
   }

   /**
    * @method viewAddNext()
    * Add the next selector row After this Operation:
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @param {webixNode} topView
    *        the current webix node that needs this view added to
    *        NOTE: this should be the top container that is adding a new
    *        row for each operation.
    */
   viewAddNext(id, topView) {
      const uiRow = this.uiNextRow(id);

      topView.addView(uiRow);
   }

   /**
    * @method viewAddParams()
    * Add operation parameter(s) for each parameterDefinition we have defined.
    * @param {string} id
    *        the unique id for where the properties panel is displayed.
    * @param {webixNode} rowView
    *        the current webix node that needs this view added to
    *        NOTE: this should be the ROW that the parameters are added to
    */
   viewAddParams(id, rowView) {
      const params = [];

      this.parameterDefinitions.forEach((pDef) => {
         // get the definition from .uiParamUI()
         params.push(this.uiParamUI(pDef, id));
      });

      let toInsert = null;

      // stack parameters in a row if there are more than 1
      if (params.length > 1)
         toInsert = {
            rows: params,
         };
      else toInsert = params.pop();

      if (toInsert) {
         rowView.removeView(rowView.getChildViews()[1]);
         rowView.addView(toInsert);
      }
   }

   ////
   //// QueryString Parser routines:
   ////

   /*
     * parseQuery()
     * check the given query string input and see if this object is the
     * starting object.
     * @param {string} query
     *			 the entered query string operation.
     * @return {bool}
     * /
    static parseQuery(query) {
        // we want to see if the beginning of this query matches our
        // option_begin string.
        const begQuery = query;
        if (query.length > this.option_begin.length) {
            begQuery = query.slice(0, this.option_begin.length);
        }
        if (this.option_begin.indexOf(begQuery) === 0) {
            return true;
        }
        return false;
    }



    /// ABApplication data methods

    tabComplete() {
        if (this._suggestions) {
            // if our begin tag is  present in _suggestions
            if (
                this._suggestions.indexOf(this.constructor.option_begin) !== -1
            ) {
                // this is probably finishing out our command:
                this.currQuery = this._suggestions;
            } else {
                // we are suggesting a parameter value:
                this.currQuery = `${this.constructor.option_begin}${this._suggestions}`;
            }

            // now make sure we do another refresh to get another
            // suggestion.
            this.fromQuery(this.currQuery);
        }
    }

    paramsToString() {
        const strs = [];
        this.parameterDefinitions.forEach((pDef) => {
            strs.push(this.params[pDef.name]);
            // switch (pDef.type) {
            //     case "objectName":
            //         strs.push(this.params[pDef.name]);
            //         break;
            // }
        });

        return strs.join(",");
    }

    /**
     * @method toObj()
     *
     * properly compile the current state of this ABView instance
     * into the values needed for saving to the DB.
     *
     * @return {json}
     * /
    toQuery() {
        if (this.entryComplete) {
            return `${this.prevOP ? this.prevOP.toQuery() : ""}${
                this.constructor.option_begin
            }${this.params ? this.paramsToString() : ""})`;
        } else {
            return `${this.prevOP ? this.prevOP.toQuery() : ""}${
                this.currQuery ? this.currQuery : ""
            }`;
        }
    }

    fromQuery(queryString) {
        const results = this.constructor.regEx.exec(queryString);
        if (results) {
            this.entryComplete = true;
            this.queryValid = true;
            this.params = {};

            if (this.paramsValid(results[1])) {
                // now progress on to any next operations:
                const newQuery = queryString.replace(this.constructor.regEx, "");
                const matchingOPs = [];
                this.constructor.NextQLOps.forEach((OP) => {
                    if (OP.parseQuery(newQuery)) {
                        matchingOPs.push(OP);
                    }
                });
                if (matchingOPs.length === 1) {
                    // exact match, so add next:
                    const qlOP = new matchingOPs[0](
                        {},
                        this,
                        this.task,
                        this.application
                    );
                    qlOP.fromQuery(newQuery);
                    this.next = qlOP;
                }

                // if there were no matching OPs, then they typed an error:
                if (matchingOPs.length === 0) {
                    this.queryValid = false;
                }
            } else {
                // I don't recoginze these params!
                this.queryValid = false;
                this._suggestions = " ! Invalid Params !";
            }
        } else {
            this.currQuery = queryString;
            this.queryValid = true; // assume true then set to false later
            this._suggestions = null;

            // calculate the processing of our command + params:
            // if we have finished our begining
            if (this.currQuery.indexOf(this.constructor.option_begin) === 0) {
                const param = this.currQuery.slice(
                    this.constructor.option_begin.length
                );

                this.paramsFromQuery(param);
            } else {
                // else they need to finish the beginning
                this._suggestions = this.constructor.option_begin;
            }

            // if we didn't have any suggestions, then what they typed
            // doesn't match, so remove the last character:
            if (!this._suggestions) {
                this.currQuery = this.currQuery.slice(0, -1);
                this.queryValid = false;
                this._suggestions = null;

                // try to regenerate the suggestions again:
                const param = this.currQuery.slice(
                    this.constructor.option_begin.length
                );

                this.paramsFromQuery(param);
            }
        }
    }

    firstOP() {
        if (!this.prevOP) {
            return this;
        } else {
            return this.prevOP.firstOP();
        }
    }

    lastOP() {
        if (!this.entryComplete) {
            return this;
        } else {
            // now figure out which of our nextOps are being used.
            if (this.next) {
                return this.next.lastOP();
            } else {
                // we haven't specified a next OP, so we are still up.
                return this;
            }
        }
    }

    paramPull(paramDef, queryString) {
        const result = { param: queryString, balance: 0 };
        if (queryString.length > 0) {
            switch (paramDef.type) {
                case "objectName":
                    // define a lexer for objectNames
                    const lexerObjectName = moo.compile({
                        comma: { match: "," },
                        name: {
                            match: /"(?:\\["\\]|[^\n"\\])*"/
                            // value: (s) => s.slice(1, -1)
                        },
                        WS: /[ \t]+/,
                        currKey: moo.error
                    });
                    lexerObjectName.reset(queryString);
                    const name = "";
                    const foundObj = null;
                    const token = lexerObjectName.next();

                    if (token) {
                        // if this is the 2nd time through, might
                        // begin with a ','
                        while (token.type === "comma") {
                            token = lexerObjectName.next();
                        }

                        // pull the parameter from the current queryString
                        if (["name", "currKey"].indexOf(token.type) !== -1) {
                            name = token.value;
                        }
                        result.param = name;
                    }

                    break;

                case "objectConditions":
                case "objectValues":
                    // define a lexer for objectConditions
                    // the goal of this lexer is to achieve json balance
                    // ( equal # of { & }) while reaching an end condition:
                    const lexerObjectCond = moo.compile({
                        comma: { match: "," },
                        colon: { match: ":" },
                        lbrace: { match: "{" },
                        rbrace: { match: "}" },
                        rparen: { match: ")" },
                        keyval: {
                            match: /"(?:\\["\\]|[^\n"\\])*"/
                            // value: (s) => s.slice(1, -1)
                        },
                        WS: /[ \t]+/,
                        currKey: moo.error
                    });
                    lexerObjectCond.reset(queryString);
                    const balance = 0;
                    const foundObj = null;
                    const token = lexerObjectCond.next();
                    const stop = false;
                    const param = "";
                    while (token && !stop) {
                        if (token.type === "lbrace") {
                            balance++;
                        }
                        if (token.type === "rbrace") {
                            balance--;
                        }

                        // check for stop condition:
                        // when balance is achieved and we find a ","
                        if (balance === 0) {
                            if (token.type === "comma") {
                                stop = true;
                            }
                        }

                        if (!stop) {
                            param += token.value;
                            token = lexerObjectCond.next();
                        }
                    }
                    result.param = param;
                    result.balance = balance;
                    break;
            }
        }

        return result;
    }

    suggestionComplete() {
        const params = [];
        this.parameterDefinitions.forEach((pDef) => {
            params.push(this.params[pDef.name]);
        });
        return `${this.constructor.option_begin}${params.join(",")})`;
    }

    /**
     * @method paramsFromQuery()
     * take the given queryString value and see if it matches our
     * possible parameter values.
     * we update ._suggestions based upon the current param state.
     * @param {string} queryString
     * /
    paramsFromQuery(queryString) {
        const keepGoing = true;
        const current = queryString;

        // for each of our parameters,
        this.parameterDefinitions.forEach((pDef) => {
            if (!keepGoing) return;

            // pull the current param
            const pullResult = this.paramPull(pDef, current);
            current = current.replace(pullResult.param, "");

            // if this param is NOT valid
            if (!this.paramIsValid(pDef, pullResult)) {
                // don't keep going after this
                keepGoing = false;

                // offer suggestions for this param
                switch (pDef.type) {
                    case "objectName":
                        // return suggestions for our parameters
                        const suggestions = [];
                        const objects = this.application.objects((o) => {
                            const quotedLabel = `"${o.label}"`;
                            return (
                                pullResult.param.length === 0 ||
                                quotedLabel.indexOf(pullResult.param) === 0
                            );
                        });
                        objects.forEach((o) => {
                            suggestions.push(`"${o.label}"`);
                        });
                        this._suggestions = suggestions.join("\n");
                        break;

                    case "objectConditions":
                    case "objectValues":
                        const paramComplete = false;
                        const paramObj = null;
                        try {
                            paramObj = JSON.parse(pullResult.param);
                            paramComplete = true;
                        } catch (e) {}

                        if (paramComplete) {
                            this.paramObj = paramObj;
                            this.params[pDef.name] = pullResult.param;
                            // this.entryComplete = true;
                            this._suggestions = this.suggestionComplete();
                        } else {
                            // define a lexer to help us parse through the provided cond string
                            const lexer = moo.states({
                                start: {
                                    lbrace: { match: "{", push: "key" }
                                },
                                key: {
                                    colon: { match: ":", push: "value" },
                                    rparen: { match: ")", pop: true },
                                    key: {
                                        match: /"(?:\\["\\]|[^\n"\\])*"/
                                        // value: (s) => s.slice(1, -1)
                                    },
                                    WS: /[ \t]+/,
                                    currKey: moo.error
                                },
                                value: {
                                    // lbrace: { match: "{", push: "complexValue" },
                                    rbrace: { match: "}", pop: true },
                                    valueContext: {
                                        match: /"\$context\((?:\\["\\]|[^\n"\\])*?\)"/
                                    },
                                    value: {
                                        match: /"(?:\\["\\]|[^\n"\\])*"/
                                    },
                                    comma: { match: ",", pop: true },
                                    currVal: moo.error
                                }
                            });

                            // now follow our state, to figure out if we are entering a
                            // key, or a value, and then figure out how to offer suggestions
                            // based upon what they are entering now:
                            const state = "start";
                            lexer.reset(pullResult.param);
                            const token = lexer.next();
                            const lastToken = null;
                            const lastKey = null;
                            while (token) {
                                switch (state) {
                                    case "start":
                                        if (token.type === "lbrace") {
                                            state = "key";
                                        }
                                        break;
                                    case "key":
                                        if (token.type === "colon") {
                                            state = "value";
                                        }
                                        if (token.type === "key") {
                                            lastKey = token.value;
                                        }
                                        break;

                                    case "value":
                                        if (token.type === "comma") {
                                            state = "key";
                                        }
                                        break;
                                }
                                lastToken = token;
                                token = lexer.next();
                            }

                            // by this point, we have ended on a state, and can figure out
                            // what to suggest:
                            switch (state) {
                                case "start":
                                    // if we ended here, then we didn't even have our first {
                                    this._suggestions = "{cond}";
                                    break;

                                case "key":
                                    // we are entering a Key, so suggest the available fields
                                    // from this object
                                    const currKey = "";
                                    const types = ["key", "currKey"];
                                    if (types.indexOf(lastToken.type) !== -1) {
                                        currKey = lastToken.value;
                                    }
                                    this._suggestions = this.fieldList(currKey);

                                    // if we end up with ._suggestions === currKey
                                    // then the key is complete, and we need to now enter ":"
                                    if (this._suggestions === currKey) {
                                        this._suggestions = ":";
                                    }
                                    break;

                                case "value":
                                    // entering a value, decide what to suggest based on what
                                    // the current key/field we are on:
                                    const currValue = "";
                                    const types = [
                                        "value",
                                        "valueContext",
                                        "currVal"
                                    ];
                                    if (types.indexOf(lastToken.type) !== -1) {
                                        currValue = lastToken.value;
                                    }
                                    this._suggestions = this.valueList(
                                        lastKey,
                                        currValue
                                    );
                                    break;
                            }
                        }

                        break;
                }
            }
        });

        if (keepGoing) {
            // none of our params were invalid, so just suggest to complete our
            this._suggestions = this.suggestionComplete();
        }
    }

    paramIsValid(paramDef, pullResult) {
        const isValid = true;
        this.params = this.params ?? {};
        switch (paramDef.type) {
            case "objectName":
                // verify it is valid
                const param = pullResult.param;
                const foundObj = null;
                if (param) {
                    // see if we find a Matching Object
                    foundObj = this.application.objects((o) => {
                        const quotedLabel = `"${o.label}"`;
                        return (
                            param.length === 0 || quotedLabel.indexOf(param) === 0
                        );
                    })[0];
                    if (foundObj) {
                        this.params[paramDef.name] = param;
                        // it is NOT valid unless it is an exact match:
                        if (`"${foundObj.label}"` !== param) {
                            isValid = false;
                        }
                    }
                }
                isValid = isValid && param.length > 0 && foundObj;
                break;

            case "objectConditions":
            case "objectValues":
                if (pullResult.balance === 0) {
                    this.params[paramDef.name] = pullResult.param;
                }
                isValid =
                    isValid &&
                    pullResult.balance === 0 &&
                    pullResult.param.length > 0;
                break;
        }

        return isValid;
    }
    /**
     * @method paramsValid()
     * parse through the given text and see if our defined parameters
     * can be properly represented.
     * @param {string} queryString
     *        the current value of the text that is the parameter(s) to our
     *        function.
     * @return {bool}
     *         true : if every parameter parses
     *         false: otherwise
     * /
    paramsValid(queryString) {
        // queryString represents the full text parameters. Might be > 1 params

        const current = queryString;
        const isValid = true; // so optimistic.

        // for each of our defined parameters
        this.parameterDefinitions.forEach((pDef) => {
            const pullResult = this.paramPull(pDef, current);
            current = current.replace(pullResult.param, "");
            isValid = isValid && this.paramIsValid(pDef, pullResult);
        });

        return isValid;
    }

    suggestions() {
        if (this.entryComplete) {
            // return suggestions for next operations.
            const suggestions = [];

            this.constructor.NextQLOps.forEach((OP) => {
                suggestions.push(OP.option);
            });
            return suggestions.join("\n");
        } else {
            return this._suggestions;
        }
    }
    */
}

module.exports = ABQL;
